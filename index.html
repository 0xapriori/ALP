<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSM Technical Product Requirements | HyperCow on Anoma</title>
    <style>
        :root {
            --primary-color: #3b82f6;
            --secondary-color: #60a5fa;
            --text-color: #e5e7eb;
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --code-bg: #0f172a;
            --border-color: #334155;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --header-gradient-start: #1e293b;
            --header-gradient-end: #0f172a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, var(--header-gradient-start), var(--header-gradient-end));
            color: white;
            padding: 60px 0;
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .toc {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 40px;
        }

        .toc h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: var(--secondary-color);
        }

        .toc ol {
            list-style-position: inside;
            margin-left: 20px;
        }

        .toc li {
            margin: 8px 0;
            color: var(--text-color);
        }

        .toc a {
            color: var(--text-color);
            text-decoration: none;
            transition: color 0.3s;
        }

        .toc a:hover {
            color: var(--secondary-color);
        }

        section {
            margin-bottom: 60px;
        }

        h2 {
            font-size: 2rem;
            color: var(--secondary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        h3 {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin: 30px 0 15px 0;
        }

        h4 {
            font-size: 1.2rem;
            color: var(--text-color);
            margin: 20px 0 10px 0;
            font-weight: 600;
        }

        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        ul, ol {
            margin-bottom: 15px;
            margin-left: 30px;
        }

        li {
            margin-bottom: 8px;
        }

        .version-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .version-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
            border-color: var(--primary-color);
        }

        .version-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .version-badge {
            background: var(--primary-color);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-right: 10px;
        }

        pre {
            background: #0a0f1e;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            border: 1px solid var(--border-color);
        }

        code {
            background: var(--card-bg);
            color: var(--secondary-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 0.9rem;
        }

        pre code {
            background: transparent;
            padding: 0;
        }

        .architecture-diagram {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            color: var(--secondary-color);
        }

        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .metric-card {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            transition: transform 0.3s, border-color 0.3s;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            border-color: var(--primary-color);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            margin: 10px 0;
        }

        .metric-label {
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .feature-item {
            display: flex;
            align-items: start;
            gap: 10px;
        }

        .feature-icon {
            color: var(--success-color);
            font-size: 1.2rem;
            margin-top: 2px;
        }

        .highlight-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning-color);
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
            color: var(--text-color);
        }

        .highlight-box strong {
            color: var(--warning-color);
        }

        .timeline {
            position: relative;
            padding-left: 40px;
            margin: 20px 0;
        }

        .timeline::before {
            content: '';
            position: absolute;
            left: 10px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border-color);
        }

        .timeline-item {
            position: relative;
            margin-bottom: 30px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -35px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--primary-color);
            border: 3px solid var(--bg-color);
            box-shadow: 0 0 0 2px var(--primary-color);
        }

        .timeline-date {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .button {
            display: inline-block;
            background: var(--primary-color);
            color: white;
            padding: 12px 24px;
            border-radius: 6px;
            text-decoration: none;
            font-weight: 500;
            transition: background 0.3s;
            margin: 10px 10px 10px 0;
        }

        .button:hover {
            background: var(--secondary-color);
        }

        .button-secondary {
            background: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }

        .button-secondary:hover {
            background: var(--primary-color);
            color: white;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        footer {
            text-align: center;
            padding: 40px 0;
            margin-top: 80px;
            border-top: 1px solid var(--border-color);
            color: #94a3b8;
        }

        /* Scrollbar styling for dark mode */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-color);
        }

        /* Link styling */
        a {
            color: var(--secondary-color);
            transition: color 0.3s;
        }

        a:hover {
            color: var(--primary-color);
        }

        /* Selection styling */
        ::selection {
            background: rgba(59, 130, 246, 0.3);
            color: white;
        }
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            .container {
                padding: 10px;
            }
            
            header {
                padding: 40px 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>MSM Technical Product Requirements</h1>
            <p class="subtitle">HLP-Style Liquidity Provision with Metastability for HyperCow on Anoma</p>
        </div>
    </header>

    <div class="container">
        <div class="toc">
            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#executive-overview">Executive Overview</a></li>
                <li><a href="#version-summaries">Version Summaries (v0.1, v0.2, v0.3)</a></li>
                <li><a href="#architecture">Architecture Design Principles</a></li>
                <li><a href="#specifications">Core Technical Specifications</a></li>
                <li><a href="#implementation">Detailed Implementation Requirements</a></li>
                <li><a href="#risk-management">Risk Management Framework</a></li>
                <li><a href="#performance">Performance Metrics</a></li>
            </ol>
        </div>

        <section id="executive-overview">
            <h2>1. Executive Overview</h2>
            <p>The MSM (Metastability Mechanism) integrates HLP-style liquidity provisioning with advanced metastability features for the HyperCow P2P DEX built on Anoma. This system provides deep liquidity, fast fills, and maintains stability through volatile market conditions by converting short-term volatility into long-term stability.</p>

            <h3>Key Objectives</h3>
            <div class="metric-grid">
                <div class="metric-card">
                    <div class="metric-label">Deep Liquidity</div>
                    <div class="metric-value">&gt;$100M</div>
                    <div class="metric-label">liquidity depth across major pairs</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Fast Fills</div>
                    <div class="metric-value">&lt;1s</div>
                    <div class="metric-label">execution with minimal slippage</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Capital Efficiency</div>
                    <div class="metric-value">&gt;95%</div>
                    <div class="metric-label">utilization through dynamic allocation</div>
                </div>
            </div>

            <h3>Architectural Principles</h3>
            <h4>1. Unified Protocol Design</h4>
            <ul>
                <li>Single, cohesive system architecture from ground up</li>
                <li>All components designed to work together natively</li>
                <li>No bolt-on integrations or adapter patterns</li>
                <li>Shared state management across all modules</li>
                <li>Unified governance and parameter adjustment</li>
            </ul>

            <h4>2. Modular Component Architecture</h4>
            <ul>
                <li>Clean interfaces between major subsystems</li>
                <li>Hot-swappable strategy modules</li>
                <li>Pluggable oracle implementations</li>
                <li>Extensible vault types</li>
                <li>Composable risk management layers</li>
            </ul>
        </section>

        <section id="version-summaries">
            <h2>2. Version Summaries</h2>

            <div class="version-card">
                <div class="version-header">
                    <span class="version-badge">v0.1</span>
                    <h3>Foundation (3 months)</h3>
                </div>
                <h4>Core MSM Implementation with Basic HLP Features</h4>
                <p><strong>Key Deliverables:</strong></p>
                <ul>
                    <li>Basic metastability mechanism with LP positions</li>
                    <li>Single USDC vault with 4-day lock period</li>
                    <li>Intent-compatible order placement system</li>
                    <li>Integration with Anoma resource machine</li>
                    <li>Basic impermanent loss protection system</li>
                </ul>
                <p><strong>Technical Targets:</strong></p>
                <ul>
                    <li>Support 10+ spot trading pairs (ETH/USDC, WBTC/USDC, etc.)</li>
                    <li>Handle 10,000 intents/second</li>
                    <li>Maintain &lt;100ms intent processing</li>
                    <li>$10M initial TVL capacity</li>
                </ul>
            </div>

            <div class="version-card">
                <div class="version-header">
                    <span class="version-badge">v0.2</span>
                    <h3>Enhanced Metastability (4 months)</h3>
                </div>
                <h4>Advanced Market Regime Detection and Multi-Asset Support</h4>
                <p><strong>Key Deliverables:</strong></p>
                <ul>
                    <li>Multi-state metastability detection</li>
                    <li>Dynamic fee adjustment based on volatility</li>
                    <li>Multi-collateral support (ETH, WBTC, stablecoins)</li>
                    <li>Enhanced solver integration for HyperCow</li>
                    <li>Advanced risk metrics and monitoring</li>
                </ul>
                <p><strong>Technical Targets:</strong></p>
                <ul>
                    <li>50+ supported spot pairs</li>
                    <li>ML-based volatility prediction</li>
                    <li>95%+ metastability detection accuracy</li>
                    <li>$100M TVL capacity</li>
                </ul>
            </div>

            <div class="version-card">
                <div class="version-header">
                    <span class="version-badge">v0.3</span>
                    <h3>Production Scale (6 months)</h3>
                </div>
                <h4>Full MSM with Institutional Features</h4>
                <p><strong>Key Deliverables:</strong></p>
                <ul>
                    <li>Complete metastability governance system</li>
                    <li>Professional API suite for algorithmic traders</li>
                    <li>Advanced arbitrage protection mechanisms</li>
                    <li>Cross-protocol liquidity aggregation</li>
                    <li>Comprehensive monitoring dashboard</li>
                </ul>
                <p><strong>Technical Targets:</strong></p>
                <ul>
                    <li>100+ spot pairs supported</li>
                    <li>Institutional-grade latency (&lt;10ms)</li>
                    <li>$500M+ TVL capacity</li>
                    <li>99.9% uptime SLA</li>
                </ul>
            </div>
        </section>

        <section id="architecture">
            <h2>3. Architecture Design Principles</h2>

            <h3>3.1 System Architecture</h3>
            <div class="architecture-diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         HyperCow MSM                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Metastabilityâ”‚  â”‚   Liquidity  â”‚  â”‚  Intent Processing â”‚   â”‚
â”‚  â”‚   Engine     â”‚  â”‚    Vaults    â”‚  â”‚     & Solving      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚                  â”‚                     â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Anoma Resource Machine                       â”‚  â”‚
â”‚  â”‚  (State Management, Intent Verification, Commitments)     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â”‚                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Anoma Paxos Consensus (4-node network)            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            </div>

            <h3>3.2 Unified vs Modular Design</h3>
            
            <h4>Unified Design Benefits:</h4>
            <div class="feature-list">
                <div class="feature-item">
                    <span class="feature-icon">âœ“</span>
                    <span>Shared liquidity pools across all functions</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">âœ“</span>
                    <span>Single governance token and parameter set</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">âœ“</span>
                    <span>Unified risk management across all positions</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">âœ“</span>
                    <span>Consistent user experience and API</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">âœ“</span>
                    <span>Lower gas costs through optimized state management</span>
                </div>
            </div>

            <h4>Modular Components:</h4>
            <pre><code class="language-rust">// Core trait definitions for modular components
trait LiquidityProvider {
    fn provide_liquidity(&mut self, amount: u256, asset: Asset) -> Result<Shares>;
    fn withdraw_liquidity(&mut self, shares: Shares) -> Result<(u256, Asset)>;
}

trait MetastabilityDetector {
    fn detect_market_state(&self, market_data: &MarketData) -> MarketState;
    fn get_stability_score(&self) -> f64;
}

trait IntentSolver {
    fn solve_intent(&self, intent: Intent, liquidity: &LiquidityPool) -> Solution;
    fn estimate_execution(&self, intent: Intent) -> ExecutionEstimate;
}

trait RiskManager {
    fn assess_risk(&self, position: Position, market_state: MarketState) -> RiskScore;
    fn enforce_limits(&mut self, position: &mut Position) -> Result<()>;
}</code></pre>
        </section>

        <section id="specifications">
            <h2>4. Core Technical Specifications</h2>

            <h3>4.1 Metastability Mechanism</h3>
            <pre><code class="language-rust">pub struct MetastabilityMechanism {
    // Core state
    pub treasury: HashMap<Asset, u256>,
    pub lp_positions: HashMap<AssetPair, LPPosition>,
    pub stability_targets: HashMap<Asset, StabilityTarget>,
    pub current_state: MarketState,
}

pub struct StabilityTarget {
    pub target_level: u256,        // Target amount in LP
    pub min_entry_price: u256,     // Minimum price in XAN
    pub current_deposited: u256,   // Amount already deposited
    pub active: bool,
}

impl MetastabilityMechanism {
    pub fn deposit_for_stability(&mut self, asset: Asset, amount: u256) -> Result<u256> {
        let target = self.stability_targets.get(&asset)
            .ok_or(Error::AssetNotSupported)?;
        
        // Check if target reached
        if target.current_deposited >= target.target_level {
            return Err(Error::TargetReached);
        }
        
        // Calculate XAN to mint based on current price
        let current_price = self.get_oracle_price(asset)?;
        if current_price < target.min_entry_price {
            return Err(Error::PriceBelowMinimum);
        }
        
        let xan_amount = amount * current_price / PRECISION;
        
        // Create LP position
        let lp_shares = self.create_lp_position(asset, amount, xan_amount)?;
        
        // Update state
        self.treasury.insert(asset, self.treasury[&asset] + amount);
        target.current_deposited += amount;
        
        Ok(lp_shares)
    }
}</code></pre>

            <h3>4.2 HLP-Style Vault Implementation</h3>
            <pre><code class="language-rust">pub struct MSMVault {
    pub total_assets: u256,
    pub total_shares: u256,
    pub locked_until: HashMap<Address, u64>, // 4-day lock
    pub user_shares: HashMap<Address, u256>,
    pub performance_metrics: PerformanceTracker,
}

impl MSMVault {
    pub fn deposit(&mut self, user: Address, amount: u256) -> Result<u256> {
        // Calculate shares
        let shares = if self.total_shares == 0 {
            amount // First depositor gets 1:1
        } else {
            amount * self.total_shares / self.total_assets
        };
        
        // Update state
        self.total_assets += amount;
        self.total_shares += shares;
        self.user_shares[&user] += shares;
        self.locked_until.insert(user, current_timestamp() + LOCK_PERIOD);
        
        // Update performance metrics
        self.performance_metrics.record_deposit(amount);
        
        Ok(shares)
    }
}</code></pre>

            <h3>4.3 Market Making Strategy with Metastability</h3>
            <pre><code class="language-rust">pub struct MetastableMarketMaker {
    base_spread: f64,
    inventory_limits: HashMap<Asset, u256>,
    metastability_adjustments: MetastabilityConfig,
    impermanent_loss_tracker: ILTracker,
}

impl MetastableMarketMaker {
    pub fn calculate_quotes(&self, 
        pair: SpotPair, 
        market_state: MarketState,
        current_inventory: Inventory
    ) -> (Option<Quote>, Option<Quote>) {
        
        let mid_price = self.get_mid_price(pair);
        let volatility = self.calculate_volatility(pair);
        
        // Adjust spread based on market state
        let spread = match market_state {
            MarketState::Stable => self.base_spread,
            MarketState::PreTransition => self.base_spread * 1.5,
            MarketState::Transitioning => self.base_spread * 2.5,
            MarketState::Metastable => self.base_spread * 2.0,
            MarketState::PostTransition => self.base_spread * 1.2,
        };
        
        // Inventory skew for spot markets
        let inventory_ratio = current_inventory.get(&pair.base) / self.inventory_limits[&pair.base];
        let skew = self.calculate_inventory_skew(inventory_ratio);
        
        // Impermanent loss adjustment
        let il_adjustment = self.impermanent_loss_tracker.get_adjustment(pair, volatility);
        
        // Calculate bid/ask with IL protection
        let bid_price = mid_price * (1.0 - spread - skew - il_adjustment);
        let ask_price = mid_price * (1.0 + spread + skew + il_adjustment);
        
        // Size based on market state and available inventory
        let size_multiplier = self.get_size_multiplier(market_state);
        let bid_size = self.calculate_optimal_size(pair, Side::Bid) * size_multiplier;
        let ask_size = self.calculate_optimal_size(pair, Side::Ask) * size_multiplier;
        
        (
            Some(Quote { price: bid_price, size: bid_size, side: Side::Bid }),
            Some(Quote { price: ask_price, size: ask_size, side: Side::Ask })
        )
    }
}</code></pre>
        </section>

        <section id="implementation">
            <h2>5. Detailed Implementation Requirements</h2>

            <h3>5.1 v0.1 Implementation Details</h3>
            
            <h4>Core Contracts</h4>
            <pre><code class="language-rust">// Main MSM contract interacting with Anoma resource machine
pub struct MSMCore {
    vaults: HashMap<VaultId, MSMVault>,
    metastability: MetastabilityMechanism,
    market_maker: MetastableMarketMaker,
    oracle: OracleSystem,
}

// Resource definitions for Anoma
pub struct MSMResource {
    logic: MSMLogic,
    label: ResourceLabel,
    quantity: u256,
    value: MSMResourceData,
    nonce: [u8; 32],
}</code></pre>

            <h4>Intent Processing</h4>
            <ul>
                <li>Integration with HyperCow P2P discovery network</li>
                <li>Solver competition for best execution</li>
                <li>Batch settlement every 10 seconds</li>
                <li>Priority fee mechanism for ordering</li>
            </ul>

            <h4>Risk Parameters</h4>
            <div class="highlight-box">
                <ul>
                    <li>Maximum position size: <strong>10% of vault</strong></li>
                    <li>Maximum price impact: <strong>2% per trade</strong></li>
                    <li>Minimum liquidity depth: <strong>$100k per side</strong></li>
                    <li>IL protection threshold: <strong>5% loss</strong></li>
                </ul>
            </div>

            <h3>5.2 v0.2 Implementation Details</h3>

            <h4>Enhanced Metastability Detection</h4>
            <pre><code class="language-rust">pub struct MarketRegimeDetector {
    volatility_model: GARCH,
    liquidity_analyzer: LiquidityDepthTracker,
    flow_analyzer: OrderFlowImbalance,
    ml_ensemble: MetastabilityPredictor,
}

impl MarketRegimeDetector {
    pub fn detect_regime(&self, market_data: &MarketData) -> (MarketState, f64) {
        let features = self.extract_features(market_data);
        
        // Individual model predictions
        let vol_signal = self.volatility_model.predict(&features);
        let liq_signal = self.liquidity_analyzer.analyze(&features);
        let flow_signal = self.flow_analyzer.compute_imbalance(&features);
        let ml_prediction = self.ml_ensemble.predict(&features);
        
        // Weighted ensemble
        let weights = [0.25, 0.25, 0.25, 0.25];
        let combined_score = vol_signal * weights[0] + 
                           liq_signal * weights[1] + 
                           flow_signal * weights[2] + 
                           ml_prediction * weights[3];
        
        let state = self.score_to_state(combined_score);
        (state, combined_score)
    }
}</code></pre>

            <h4>Multi-Asset Collateral</h4>
            <ul>
                <li>Support ETH, WBTC, USDC, USDT, DAI as base liquidity assets</li>
                <li>Dynamic rebalancing based on correlation and volatility</li>
                <li>Cross-pair arbitrage detection and execution</li>
                <li>Automatic portfolio optimization for IL minimization</li>
            </ul>
        </section>

        <section id="risk-management">
            <h2>6. Risk Management Framework</h2>

            <h3>6.1 Multi-Layer Risk Controls</h3>
            <pre><code class="language-rust">pub struct RiskManagementSystem {
    position_limits: PositionLimits,
    market_risk: MarketRiskEngine,
    liquidity_risk: LiquidityRiskEngine,
    operational_risk: OperationalRiskMonitor,
}

impl RiskManagementSystem {
    pub fn evaluate_risk(&self, action: Action, current_state: SystemState) -> RiskAssessment {
        let market_risk = self.market_risk.assess(action, current_state);
        let liquidity_risk = self.liquidity_risk.assess(action, current_state);
        let operational_risk = self.operational_risk.assess(action, current_state);
        
        RiskAssessment {
            total_risk_score: market_risk.score * 0.5 + 
                            liquidity_risk.score * 0.3 + 
                            operational_risk.score * 0.2,
            can_proceed: market_risk.acceptable && 
                        liquidity_risk.acceptable && 
                        operational_risk.acceptable,
            required_adjustments: self.calculate_adjustments(market_risk, liquidity_risk),
        }
    }
}</code></pre>

            <h3>6.2 Emergency Response</h3>
            <pre><code class="language-rust">pub struct EmergencyProtocol {
    triggers: Vec<EmergencyTrigger>,
    response_actions: HashMap<TriggerType, Vec<Action>>,
    validator_threshold: u32, // Number of validators needed to activate
}

pub enum EmergencyTrigger {
    ExcessiveLosses { threshold: f64, period: u64 },
    ProlongedMetastability { duration: u64 },
    LiquidationFailures { count: u32, period: u64 },
    OracleFailure { consecutive_failures: u32 },
}</code></pre>
        </section>

        <section id="performance">
            <h2>7. Performance Metrics</h2>

            <h3>7.1 Key Performance Indicators</h3>
            <pre><code class="language-rust">pub struct MSMMetrics {
    // Liquidity metrics
    pub total_value_locked: u256,
    pub liquidity_depth: HashMap<SpotPair, LiquidityDepth>,
    pub average_spread: f64,
    pub fill_rate: f64,
    
    // Performance metrics
    pub sharpe_ratio: f64,
    pub max_drawdown: f64,
    pub daily_volume: u256,
    pub fee_revenue: u256,
    
    // Metastability metrics
    pub stability_score: f64,
    pub regime_accuracy: f64,
    pub average_state_duration: HashMap<MarketState, u64>,
    
    // Risk metrics
    pub impermanent_loss_ratio: f64,
    pub portfolio_correlation: f64,
    pub concentration_risk: f64,
}</code></pre>

            <h3>7.2 Monitoring Dashboard</h3>
            
            <h4>Real-time Metrics</h4>
            <div class="feature-list">
                <div class="feature-item">
                    <span class="feature-icon">ğŸ“Š</span>
                    <span>Current TVL and composition</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">ğŸ’¹</span>
                    <span>Active positions and P&L</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">ğŸ¯</span>
                    <span>Market state and stability score</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">âš¡</span>
                    <span>Recent fills and slippage</span>
                </div>
                <div class="feature-item">
                    <span class="feature-icon">ğŸ”§</span>
                    <span>System health indicators</span>
                </div>
            </div>

            <h4>Historical Analytics</h4>
            <ul>
                <li>Performance attribution</li>
                <li>Regime transition analysis</li>
                <li>Risk factor decomposition</li>
                <li>User behavior patterns</li>
                <li>Revenue breakdown</li>
            </ul>
        </section>

        <section>
            <h2>Implementation Timeline</h2>
            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-date">Months 1-3</div>
                    <h4>v0.1 Foundation</h4>
                    <p>Core MSM implementation, basic vault system, and Anoma integration</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">Months 4-7</div>
                    <h4>v0.2 Enhancement</h4>
                    <p>Advanced metastability detection, multi-asset support, and ML integration</p>
                </div>
                <div class="timeline-item">
                    <div class="timeline-date">Months 8-9</div>
                    <h4>v0.3 Production</h4>
                    <p>Full feature set, institutional APIs, and mainnet launch</p>
                </div>
            </div>
        </section>

        <section>
            <h2>Conclusion</h2>
            <p>The MSM system represents a sophisticated integration of HLP-style liquidity provision with advanced metastability mechanisms, specifically designed for the HyperCow P2P DEX on Anoma. By combining deep liquidity, fast execution, and intelligent market regime detection, MSM provides a robust foundation for decentralized trading while maintaining stability through volatile market conditions.</p>
            
            <p>The phased approach ensures each component is thoroughly tested and optimized before moving to the next phase, with clear metrics for success at each stage. The modular architecture allows for future enhancements while maintaining the benefits of a unified protocol design.</p>

            <div style="margin-top: 40px;">
                <a href="#" class="button">View on GitHub</a>
                <a href="#" class="button button-secondary">Download PDF</a>
            </div>
        </section>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2024 HyperCow MSM. Built on Anoma for Ethereum.</p>
        </div>
    </footer>
</body>
</html>
